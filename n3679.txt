                           N3679 - Function literals

Author : Thiago R Adams  
Date   : 2025-07-11  
Project: ISO/IEC JTC 1/SC 22/WG 14  
Title  : Literal functions
Target audience: Implementers, users
Prior art: C++ lambdas without capture
Revision: r0

SUMMARY OF CHANGES
   
   * N3679 
      - "literal functions" renamed to "function literals"
      - fixed qsort sample, removed sample thrd_create

   * N3645
      - Original proposal

ABSTRACT

   This  proposal  introduces  function  literals  into  the  C language,
   providing  a  syntax  for  defining functions within expressions. This
   feature  is  particularly  useful for creating callbacks, which is the
   primary motivation for the proposal. 
  

1.  MOTIVATION

   Many  standard  C library functions (e.g., 'qsort', 'thrd_create') and
   common  APIs  rely  on  callbacks.  Today,  using  them requires extra
   boilerplate, especially for asynchronous callbacks. 

   Consider this sample:

      void async(
                 void (*callback)(int result, void * data),
                 void * data
                 );
      
      struct capture { int value; };
                
      static void main_async_complete(int result, void * data) {
         struct capture * capture = data;
         free(capture);
      }
      
      int main() {
         struct capture * capture = calloc(1, sizeof * capture); 
         async(main_async_complete, capture);
      }

   Given    the   current   state   of   the   language,   the   function
   main_async_complete,  which  is  used only once and is specific to the
   context in which it is called in main, must be declared at file scope.
   Since  it uses the struct capture, which is also tied to that specific
   callback  in  that  particular  context,  the  struct must likewise be
   declared at file scope .

   With  the introduction of function literals, we can declare the struct
   capture  and  main_async_complete  (that does not need a name anymore)
   inside the local scope.   

      void async(void (*callback)(int result, void* data), void * data);

      int main()
      {
         struct capture { 
            int value; 
         }* capture = calloc(1, sizeof * capture); 

         async((void (int result, void * capture)) {
            struct capture * p = capture;
            free(p);
         }, capture);
      }  

2.  SYNTAX AND SEMANTICS

   2.1 Syntax
 
      postfix-expression: 
         ...      
         function-literal     
  
      function-literal:
         ( type-name ) function-body 
 

   The   syntax   is   ambiguous   with   that  of  a  compound  literal.
   Disambiguation is based on the type: function literals have a function
   type, whereas compound literals do not.                               

   Function-specifiers  (_Noreturn,  inline) and storage-class specifiers
   (auto, constexpr, extern, register, static, thread_local, typedef) are
   not  permitted  in  function  literals,  as  their  semantics  are not
   currently defined in this context.


   2.2 Semantics
   
   The  function  literal is a function designator. For instance, talking
   the  address  of  a  function  literal  will return the address of the
   function. 
      
         void main()
         {      
            (void (*pf)(void)) = &(void (void)){}; //ok
                   
            //error: lvalue required as left operand of assignment
            &(void (void)){} = 0; 
         }

   
   Identifiers  from  the  enclosing scope, excluding labels, are visible
   inside the function literal.  

      Samples:

         int main() {      
            enum E {A};
            int i = 0;
            (void (void)) {
               int j = sizeof(i); //ok
               enum E e = A; //ok
            }();
         }


         int main() {      
            L1:;
            (void (void)) {
               //error: label 'L1' used but not defined
               goto L1; 
            }();
         }
 
    The  value  of  __func__  is an implementation-defined null-terminated
    string when used inside function literals. For comparison, C++ lambdas
    returns "operator ()".
      
    Function  literals cannot access the storage of objects with automatic
    storage  duration or VM types from the enclosing function within their
    function-body.    

    Samples:

      int main() {
         int i = 0;
         (void(void)){ i = 1; /*error*/ }();
      }

      int main() {
        int i = 0;
        (void(void)){ int j = sizeof(i); /*ok*/ }();
      }

      int g;
      int main() {
         (void(void)){ g = 1; /*ok*/ }();
      }

      int main() {
         int f();
         (void ()){ f(); /*ok*/}();      
      }

      int main() {
         static int i = 0;
         (void ()){ i = 1; /*ok*/ }();      
      }

 
      int f(int n) {
         int ar[n];
         (void ()){ typeof(ar) b; /*error*/ }();      
      }
   

   A  type declared in the result of a function literal has the enclosing
   scope, either block or file scope.                                    

   A  type  declared  within the parameter list of a function literal has
   block scope, which is the function literal body itself.

   Sample:

      int main() {
         (struct X { int i; } (struct Y *y)) {
            struct X x = {};
            return x;
         }(nullptr);

        struct X x; //ok
        struct Y y; /*error*/
      }

      void f(int n) {

         int a[n];
         int (*aa)[n] = &a;
         auto f = (int (*(int n, int (*aa)[n]))[n])
         {
           return aa;
         }    
         f(n, aa);
      }


3.  GENERIC FUNCTIONS

   A function literal may result in the instantiation of distinct 
   functions depending on the arguments provided.  For example:

      #define SWAP(a, b)\
       (void (typeof(a)* arg1, typeof(b)* arg2)) { \
         typeof(a) temp = *arg1; *arg1 = *arg2; *arg2 = temp; \
       }(&(a), &(b))

      int main() {
         int a = 1;
         int b = 2;
         SWAP(a, b);
      }


      #define NEW(...)\
       (typeof((__VA_ARGS__))* (void)){\
          typeof(__VA_ARGS__)* _p = malloc(sizeof * _p);\
            if (_p) *_p = __VA_ARGS__;\
            return _p;\
      }()

      struct X { const int i; };

      int main() {
         auto p2 = NEW((struct X) {});
      }         

4.  RATIONALY

   Functions literals improve the C language without introducing new 
   concepts, providing more flexibility to functions and enabling a form
   of generic functions in C.

   4.1  Why not C++ lambdas syntax?
   
      Maintaining the existing C grammar is the safest option, as it 
      ensures that function literal syntax stays in sync with function
      declarations and naturally preserves compatible scope rules

      Consider this sample:

         int main() {
            (struct X { int i; } ()) {
               struct X x = {};
               return x;
            }();
           struct X x = {}; /*ok*/
         }

      The scope rules for the visibility of struct X are the same as 
      those for functions. With the C++ lambda syntax, the return type
      would be specified after the parameter scope, which could 
      interfere with scope handling or complicate the implementation.

      This design also leaves room for alternative capture models that
      do not follow the C++ approach. Having different models with the
      same syntax could be confusing for users.
      
      Interoperability using a pair of pointer to function + data is 
      possible in both directions, from C to C++ and from C++ to C,
      when captureless lambdas are used.

   4.2  Why not having captures like C++ lambdas?

      When lambdas were introduced in C++, the language already included
      the necessary infrastructure for capturing such as exceptions, 
      constructors, destructors, and function objects.  In contrast, C 
      lacks these features.
   
      Low-level alternatives in C would conflict with existing available 
      patterns, while high-level abstractions might require introducing
      new concepts that may not fit well in C.

      Automatic capture of constexpr objects, or constant objects 
      declared with the register storage-qualifier, from the other 
      scope were considered. This limitation can be removed in the 
      future if necessary.
      
      Note: For comparison, C++ lambdas without captures can use 
      constexpr objects, provided their addresses are not taken.

5.  COMPATIBILITY AND IMPACT

   * This feature does not break any existing valid C programs, since
     compound literal objects of type function cannot be created in the
     current C version. 


6.  IMPLEMENTATION CONSIDERATIONS

   Literal functions can be implemented by the compiler as:

   * Anonymous 'static' functions with unique internal names.

   * Emission of a unique function symbol in the object file.

   6.1 Recommended practice

      * Identical functions literals, having the same function type and 
        function-body should, but they are not required, to produce the
        same function.

   6.1 Existing implementations

      Cake transpiler has an experimental implementation that converts 
      C2Y code to  C99.
      http://thradams.com/cake/playground.html  

      C++ lambda expressions without captures serve as prior art for 
      this feature, albeit with some differences.

7. REFERENCES

   * https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3550.pdf  
   * https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2661.pdf
   * https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2924.pdf

8. ACKNOWLEDGEMENTS

   I would like to recognize the following people for their help in this
   work: Joseph Myers, Martin Uecker, Jens Gustedt.

