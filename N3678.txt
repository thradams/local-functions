---------------------- N3678 Local functions ---------------------------

Author : Thiago R Adams  
Date   : 2025-09-30
Project: ISO/IEC JTC 1/SC 22/WG 14  
Title  : Local functions
Target audience: Implementers, users
Prior art: GCC Nested functions without capture


ABSTRACT
   
   This  proposal  introduces support for defining functions inside other
   function  definitions,  similar  to  GCC  nested functions. Unlike GCC
   nested  functions,  local  functions  do  not form closures and do not
   capture variables.  
   
        
1.  INTRODUCTION

    C currently allows function declarations inside block scope, but not 
    function definitions. 
    
    Allowing inner function definitions would enable:

    - Better organization of code.

    - Encapsulation of helper logic that is not meaningful  outside  the
      enclosing function.

    - Complements function literals N3679

   Following   the   same  principles  as  N3679,  this  proposal  avoids
   introducing  closures  (captures),  keeping  the  semantics simple and
   compatible with C's execution and memory model.  

2. SYNTAX AND SEMANTICS

   2.1 Syntax
 
      block-item:
        ...
        function-definition
      
      The  syntax  we  are proposing is the same as GCC nested functions;
      however, we have some design questions.                          

      Consider this sample: 
      
         void f() { /* external */ }

         int main() {
             void f();   /* local declaration */
             void f() {  /* local definition */
                 /* ... */
             }
             return 0;
         }
   
      We need a way to disambiguate the declaration of the local function
      'f' from its external declaration. GCC uses auto for this purpose. 

         /* GCC nested function sample */

         void f() { /*extern*/ }

         int main() {
               auto void f(); /*local*/
               void f() { }   /*auto is optional here*/
               return 0;
         }

      An  option  is to adopt the same syntax as GCC nested functions and
      rely  on  auto  for  disambiguation.  In this case, when GCC nested
      functions  do  not  capture variables, they already follow the same
      semantics and syntax as local functions.                           

      The  reason  we  are  not introducing captures is the complexity it
      brings  with  lifetimes  and  compatibility  with  normal  function
      pointers,  as  well  as concerns about the way GCC nested functions
      work.  In GCC, trampolines are a mechanism used to implement nested
      functions.                                                         

      Effectively, a trampoline is a runtime-generated function stub that
      allows  the  nested  function  to  behave  like  a  normal function
      pointer.  There  are  security  risks  associated  with trampolines
      because  they  involve  executable  code  on the stack. Many modern
      systems  mark  the stack as non-executable to prevent exploits such
      as buffer overflows.                                               

      Trampolines  are  only  required  if  the  nested function captures
      variables.  However, internally, GCC may still use trampolines even
      if  variables  are not captured, which remains a source of security
      concerns.                                                          

      For instance, the code below does not have captures. Compiling this
      code with -Wtrampolines will confirm the presence of trampolines. 
   
      /* Use -Wtrampolines in GCC */
      #include <stdio.h>

      int main() {
          void local() { printf("hello"); }
          void (*f)() = local;
          f();
          return 0;
      }

      https://godbolt.org/z/dT87xEsq7
   
      Adding  the -O1 optimization option removes both the trampoline and
      the warning.                                                       

      One  alternative design for local functions would be to require the
      storage  qualifier static explicitly, or to make its usage optional
      if  the  programmer  wishes  to mark the function as non-capturing.
      This  would,  for instance, prevent accidental captures in GCC. The
      same   qualifier   could   then   be   used  in  the  corresponding
      declarations.    
  
         void f() { /*extern*/ }

         int main() {
             static void f(); /*local*/
             static void f() { } /*static optional or mandatory?*/
             return 0;
         }
      
      In  practice,  'auto'  would  not  be  allowed  in  local  function
      declarations  and  definitions. If 'static' is optional in function
      definitions,  then  function definitions would have the same syntax
      as  GCC when 'auto' is not used. Function declarations would always
      differ.  
      
      Alternatively,  we  can  continue using 'auto', and local functions
      would  not  differ  in  syntax  from GCC nested functions. The only
      difference is that captures would not be allowed for standard local
      functions,  and  GCC  nested  functions  would  become an extension
      concerning  only  captures.  This  option is also related to N3679,
      where 'auto' would no longer serve as a storage qualifier.  

      Captures  for  local functions and function literals are also not a
      closed  subject,  and this design is still open in many ways. Using
      'static'  would  restrict  the  design  of  local  functions in its
      current  form,  and  new options could introduce a new qualifier or
      reuse the old 'auto'.     

   2.2 Semantics
      
      Local functions have semantics similar to those of local functions,
      as  described  in  N3679.  The  scope  of  the function follows the
      existing block scope.                                              

      Tags,  enumerators,  and  functions declared in the enclosing scope
      are  visible  and  can  be used in the return type, parameters, and
      body of the local function.

         int main() {      
            
            void f();
            enum E {A};

            enum E local(enum E arg) 
            {
               enum E e = A;
               f();
               return e;
            }
         }

      Labels  from  the  enclosing scope are NOT visible inside the local
      function body.    

         int main() {      
            L1:;
            void local(void)
            {
               // error: label 'L1' used but not defined
               goto L1; 
            }
         }

      VM  types  from  the enclosing scope can be used only in the return
      type  and  parameters  of  the  local  function and are not allowed
      inside the local function body. 
      
         int f(int n) {
            int ar[n];
            void local()
            { 
              typeof(ar) b; /* error */ 
            }     
         }

      Objects with automatic storage, declared in the enclosing scope and
      which  are  not  VM  types,  can  be  used  within the return type,
      arguments,  and function body of local functions, provided they are
      used in discarded expressions inside the function body. 

         Samples:

            int main() {      
               int i = 0;
               void local(void)
               {
                  int j = sizeof(i); // ok               
               }
            }

            int main() {
               int i = 0;
               void local(void) { i = 1; /* error */ }
            }


      Objects  with static storage duration declared at file or enclosing
      scope  are  visible  and can be used in the return type, arguments,
      and body of a local function.

         int g;
         int main() {
            void local(void) { g = 1; /* ok */ };
         }

         int main() {
            static int i = 0;
            void local() { 
               i = 1; /* ok */ 
            }      
         }

      The  value of __func__ is an implementation-defined null-terminated
      string  when  used  inside  local  functions.  For  comparison, GCC
      returns the name of the function.                                  

      A type declared in the result of a local function has the enclosing
      scope, either block or file scope.                                 

      A  type  declared within the parameter list of a local function has
      block scope, which is the local function body itself. 

      Sample:

         int main() {

            struct X { int i; } local(struct Y *y)) 
            {
               struct X x = {};
               return x;
            }

           struct X x; // ok
           struct Y y; /* error */
         }
  


3. COMPATIBILITY AND IMPACT

   Compatibility and impact were already discussed in the syntax section,
   where  the  main  question is the interaction with existing GCC nested
   functions.    

4. EXISTING IMPLEMENTATIONS

    - GCC nested functions without capturing variables.
    
    - Cake http://thradams.com/cake/playground.html  
      (Missing some details like VM types)

5. REFERENCES
   
   * N3645 - Literal functions
     https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3645.pdf
   
   * N3657 - Functions with Data - Closures in C 
     https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3657.htm
   
   * N3654 - Accessing the Context of Nested Functions
     https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3654.pdf
         
   * GCC - Nested functions
     https://gcc.gnu.org/onlinedocs/gcc/Nested-Functions.html

   * 3579 - auto as a placeholder type specifier, v2
     https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3579.htm

6. ACKNOWLEDGEMENTS

   I would like to recognize the following people for their help in this
   work: Martin Uecker, Alejandro Colomar, Jens Gustedt.

