---------------------- N3678 Local functions ---------------------------

Author : Thiago R Adams  
Date   : 2025-08-05  
Project: ISO/IEC JTC 1/SC 22/WG 14  
Title  : Local functions
Target audience: Implementers, users
Prior art: GCC Nested functions without capture



ABSTRACT

   
This proposal introduces support for defining functions within the definition of other functions, 
similar to GCC nested functions. The main difference is that, local functions do not form closures.
   
        
1.  INTRODUCTION

    C currently allows function declarations inside block scope, but not 
    function definitions. 
    
    Allowing inner function definitions would enable:

    - Better organization of code.

    - Encapsulation of helper logic that is not meaningful  outside  the
      enclosing function.

    - Complements function literals N3679

   Following the same principles as N3679, this proposal avoids 
   introducing closures (captures), keeping the semantics  simple and
   compatible with C's execution and memory model.

2. SYNTAX AND SEMANTICS

   2.1 Syntax
 
      block-item:
        ...
        function-definition
      
   The syntax we are proposing is the same of GCC nested function, however we have some design
   questions.

   Consider this sample:
      
      void f() { /*extern*/ }

      int main() {
          void f(); /*local*/
          void f() { }
          return 0;
      }
   
   We need a way to disambiguate the declaration of the local function f from its external declaration
   . GCC uses auto for this purpose.


     /*GCC nested function sample*/
      void f() { /*extern*/ }

      int main() {
          auto void f(); /*local*/
          void f() { }   /*auto is optional here*/
          return 0;
      }

   An option is to adopt the same syntax as GCC nested functions and rely
   on auto for disambiguation. In this case, when GCC nested functions do
   not  capture  variables,  they  already  follow the same semantics and
   syntax as local functions.                                            

   The reason we are not introducing captures is the complexity it brings
   with  lifetimes  and  compatibility  with normal function pointers, as
   well  as  concerns  about  the  way GCC nested functions work. In GCC,
   trampolines  are  a  mechanism  used  to  implement  nested functions.
   Effectively,  a  trampoline  is a runtime-generated function stub that
   allows  the  nested function to behave like a normal function pointer.
   There  are  security  risks  associated  with trampolines because they
   involve  executable  code  on  the stack. Many modern systems mark the
   stack  as non-executable to prevent exploits such as buffer overflows.
   
   Trampolines   are  only  required  if  the  nested  function  captures
   variables.  However,  internally,  GCC may still use trampolines even 
   if variables are  not  captured,  which  remains  a source of security 
   concerns, as  described   in  N3657,  "Functions  with  Data  â€“  Closures  in  C  (A
   Comprehensive  Proposal  Overviewing  Blocks,  Nested  Functions,  and
   Lambdas). 

   For instance, the code bellow does not have captures. Compiling this 
   code with -Wtrampolines will confirm the presence of trampolines.
      
      //Use -Wtrampolines in GCC
      #include <stdio.h>

      int main() {
          void local_without_capture() { printf("hello"); }
          void (*f)() = local_without_capture;
          f();
          return 0;
      }
      
   https://godbolt.org/z/G3bj36693
   
  Adding the -O1 optimization option removes both the trampoline and the warning.

  Considering, an alternative design for local function  would be require expliciy
  the storage qualifier static, or to make the usage of static optional if the programmers
  wants to explicity mark the funciton as non capture even if some capture is made by mitake 
  in the GCC compiler.
  

      void f() { /*extern*/ }

      int main() {
          static void f(); /*local*/
          static void f() { } /*static optional or mandatory?*/
          return 0;
      }


  This is the main design question we have. 
  

   2.2 Semantics
      

      Local functions have semantics similar to those of local functions, as described in N3679.
      The scope of the function follows the existing block scope.


      Tags,  enumerators,  and  functions declared in the enclosing scope
      are  visible  and  can  be used in the return type, parameters, and
      body of the local function.     

         int main() {      
            
            void f();
            enum E {A};

            enum E local(enum E arg) 
            {
               enum E e = A;
               f();
               return e;
            }
         }

      Labels from the enclosing scope are NOT visible inside the local
      function body.  

        int main() {      
            L1:;
            void local(void)
            {
               // error: label 'L1' used but not defined
               goto L1; 
            }
         }

      VM  types  from  the enclosing scope can be used only in the return
      type  and  parameters  of  the local function and are not allowed
      inside the local function body. 
      
         int f(int n) {
            int ar[n];
            void local()
            { 
              typeof(ar) b; /* error */ 
            }     
         }

      Objects with automatic storage, declared in the enclosing scope and
      which  are  not  VM  types,  can  be  used  within the return type,
      arguments,  and  function  body of local functions, provided they
      are used in discarded expressions inside the function body.

      Samples:

         int main() {      
            int i = 0;
            void local(void)
            {
               int j = sizeof(i); // ok               
            }
         }

         int main() {
            int i = 0;
            void local(void){ i = 1; /* error */ }
         }


      Objects  with static storage duration declared at file or enclosing
      scope  are  visible  and can be used in the return type, arguments,
      and body of a local function.  (TODO thread_local?)

         int g;
         int main() {
            void local(void) { g = 1; /* ok */ };
         }

         int main() {
            static int i = 0;
            void local() { 
               i = 1; /* ok */ 
            }      
         }

      The  value of __func__ is an implementation-defined null-terminated
      string  when  used  inside  local functions. For comparison, GCC 
      returns the name of the function.
      
      
      A  type  declared  in  the  result  of  a  local function has the
      enclosing scope, either block or file scope.                       

      A type declared within the parameter list of a local function has
      block scope, which is the local function body itself.  

      Sample:

         int main() {

            struct X { int i; } local(struct Y *y)) 
            {
               struct X x = {};
               return x;
            }

           struct X x; // ok
           struct Y y; /* error */
         }
  


3. COMPATIBILITY AND IMPACT

   Compatibilies and impact where already discussed on the syntax section, where
   the main question is the interecation with the existing GCC nested functions.
   

4. EXISTING IMPLEMENTATIONS

    - GCC nested functions without capturing variables.
    
    - Cake http://thradams.com/cake/playground.html  
      (Missing some details like VM types)

5. REFERENCES
   
   * N3645 - Literal functions
     https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3645.pdf
   
   * N3657 - Functions with Data - Closures in C 
     https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3657.htm
   
   * N3654 - Accessing the Context of Nested Functions
     https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3654.pdf
         
   * GCC - Nested functions
     https://gcc.gnu.org/onlinedocs/gcc/Nested-Functions.html

6. ACKNOWLEDGEMENTS

   I would like to recognize the following people for their help in this
   work: Martin Uecker, Alejandro Colomar, Jens Gustedt.

